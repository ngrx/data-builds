{"version":3,"file":"entity-definition.service.js","sourceRoot":"ng://@ngrx/data/","sources":["src/entity-metadata/entity-definition.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAE7D,OAAO,EAAE,sBAAsB,EAAoB,MAAM,qBAAqB,CAAC;AAC/E,OAAO,EAGL,qBAAqB,GACtB,MAAM,mBAAmB,CAAC;;;;AAE3B,uCAEC;;;;AAGD;IAKE,iCAGE,kBAAuC;QAHzC,iBAQC;;;;QAVgB,gBAAW,GAAsB,EAAE,CAAC;QAOnD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,OAAO;;;;YAAC,UAAA,GAAG,IAAI,OAAA,KAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAA7B,CAA6B,EAAC,CAAC;SAClE;IACH,CAAC;IAED;;;;;;;OAOG;;;;;;;;;;;;IACH,+CAAa;;;;;;;;;;;IAAb,UACE,UAAkB,EAClB,WAAkB;QAAlB,4BAAA,EAAA,kBAAkB;QAElB,UAAU,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC;;YACzB,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC;QAC/C,IAAI,CAAC,UAAU,IAAI,WAAW,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,2CAAwC,UAAU,QAAI,CAAC,CAAC;SACzE;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,wCAAwC;IAExC;;;;;;;OAOG;;;;;;;IACH,kDAAgB;;;;;;;IAAhB,UAAiB,QAAwB;QACvC,IAAI,QAAQ,EAAE;;gBACN,UAAU,GAAG,sBAAsB,CAAC,QAAQ,CAAC;YACnD,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;SACrC;IACH,CAAC;IAED;;;;;;;;;OASG;;;;;;;;;;;;IACH,qDAAmB;;;;;;;;;;;IAAnB,UAAoB,WAAmC;QAAvD,iBAKC;QALmB,4BAAA,EAAA,gBAAmC;QACrD,yDAAyD;QACzD,MAAM,CAAC,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC,OAAO;;;;QAAC,UAAA,UAAU;YAC/C,OAAA,KAAI,CAAC,gBAAgB,YAAG,UAAU,YAAA,IAAK,WAAW,CAAC,UAAU,CAAC,EAAG;QAAjE,CAAiE,EAClE,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;;;;;;;;;;IACH,oDAAkB;;;;;;;;;IAAlB,UAAsB,UAA+B;QACnD,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC;IACvD,CAAC;IAED;;;;;;;;;OASG;;;;;;;;;;;;IACH,qDAAmB;;;;;;;;;;;IAAnB,UAAoB,WAA8B;QAChD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC/C,CAAC;;gBA5FF,UAAU;;;;4CAMN,QAAQ,YACR,MAAM,SAAC,qBAAqB;;IAsFjC,8BAAC;CAAA,AA7FD,IA6FC;SA5FY,uBAAuB;;;;;;;IAElC,8CAAqD","sourcesContent":["import { Inject, Injectable, Optional } from '@angular/core';\n\nimport { createEntityDefinition, EntityDefinition } from './entity-definition';\nimport {\n  EntityMetadata,\n  EntityMetadataMap,\n  ENTITY_METADATA_TOKEN,\n} from './entity-metadata';\n\nexport interface EntityDefinitions {\n  [entityName: string]: EntityDefinition<any>;\n}\n\n/** Registry of EntityDefinitions for all cached entity types */\n@Injectable()\nexport class EntityDefinitionService {\n  /** {EntityDefinition} for all cached entity types */\n  private readonly definitions: EntityDefinitions = {};\n\n  constructor(\n    @Optional()\n    @Inject(ENTITY_METADATA_TOKEN)\n    entityMetadataMaps: EntityMetadataMap[]\n  ) {\n    if (entityMetadataMaps) {\n      entityMetadataMaps.forEach(map => this.registerMetadataMap(map));\n    }\n  }\n\n  /**\n   * Get (or create) a data service for entity type\n   * @param entityName - the name of the type\n   *\n   * Examples:\n   *   getDefinition('Hero'); // definition for Heroes, untyped\n   *   getDefinition<Hero>(`Hero`); // definition for Heroes, typed with Hero interface\n   */\n  getDefinition<T>(\n    entityName: string,\n    shouldThrow = true\n  ): EntityDefinition<T> {\n    entityName = entityName.trim();\n    const definition = this.definitions[entityName];\n    if (!definition && shouldThrow) {\n      throw new Error(`No EntityDefinition for entity type \"${entityName}\".`);\n    }\n    return definition;\n  }\n\n  //////// Registration methods //////////\n\n  /**\n   * Create and register the {EntityDefinition} for the {EntityMetadata} of an entity type\n   * @param name - the name of the entity type\n   * @param definition - {EntityMetadata} for a collection for that entity type\n   *\n   * Examples:\n   *   registerMetadata(myHeroEntityDefinition);\n   */\n  registerMetadata(metadata: EntityMetadata) {\n    if (metadata) {\n      const definition = createEntityDefinition(metadata);\n      this.registerDefinition(definition);\n    }\n  }\n\n  /**\n   * Register an EntityMetadataMap.\n   * @param metadataMap - a map of entityType names to entity metadata\n   *\n   * Examples:\n   *   registerMetadataMap({\n   *     'Hero': myHeroMetadata,\n   *     Villain: myVillainMetadata\n   *   });\n   */\n  registerMetadataMap(metadataMap: EntityMetadataMap = {}) {\n    // The entity type name should be the same as the map key\n    Object.keys(metadataMap || {}).forEach(entityName =>\n      this.registerMetadata({ entityName, ...metadataMap[entityName] })\n    );\n  }\n\n  /**\n   * Register an {EntityDefinition} for an entity type\n   * @param definition - EntityDefinition of a collection for that entity type\n   *\n   * Examples:\n   *   registerDefinition('Hero', myHeroEntityDefinition);\n   */\n  registerDefinition<T>(definition: EntityDefinition<T>) {\n    this.definitions[definition.entityName] = definition;\n  }\n\n  /**\n   * Register a batch of EntityDefinitions.\n   * @param definitions - map of entityType name and associated EntityDefinitions to merge.\n   *\n   * Examples:\n   *   registerDefinitions({\n   *     'Hero': myHeroEntityDefinition,\n   *     Villain: myVillainEntityDefinition\n   *   });\n   */\n  registerDefinitions(definitions: EntityDefinitions) {\n    Object.assign(this.definitions, definitions);\n  }\n}\n"]}