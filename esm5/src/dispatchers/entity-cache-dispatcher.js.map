{"version":3,"file":"entity-cache-dispatcher.js","sourceRoot":"ng://@ngrx/data/","sources":["src/dispatchers/entity-cache-dispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport { Action, ScannedActionsSubject, Store } from '@ngrx/store';\n\nimport { Observable, of, Subscription, throwError } from 'rxjs';\nimport { filter, mergeMap, shareReplay, take } from 'rxjs/operators';\n\nimport { CorrelationIdGenerator } from '../utils/correlation-id-generator';\nimport { EntityActionOptions } from '../actions/entity-action';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityDispatcherDefaultOptions } from './entity-dispatcher-default-options';\n\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { PersistanceCanceled } from './entity-dispatcher';\n\nimport { ChangeSet, ChangeSetItem } from '../actions/entity-cache-change-set';\nimport {\n  ClearCollections,\n  EntityCacheAction,\n  EntityCacheQuerySet,\n  LoadCollections,\n  MergeQuerySet,\n  SetEntityCache,\n  SaveEntities,\n  SaveEntitiesCancel,\n  SaveEntitiesError,\n  SaveEntitiesSuccess,\n} from '../actions/entity-cache-action';\n\n/**\n * Dispatches Entity Cache actions to the EntityCache reducer\n */\n@Injectable()\nexport class EntityCacheDispatcher {\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent action reduced by the store.\n   */\n  reducedActions$: Observable<Action>;\n  private raSubscription: Subscription;\n\n  constructor(\n    /** Generates correlation ids for query and save methods */\n    private correlationIdGenerator: CorrelationIdGenerator,\n    /**\n     * Dispatcher options configure dispatcher behavior such as\n     * whether add is optimistic or pessimistic by default.\n     */\n    private defaultDispatcherOptions: EntityDispatcherDefaultOptions,\n    /** Actions scanned by the store after it processed them with reducers. */\n    @Inject(ScannedActionsSubject) scannedActions$: Observable<Action>,\n    /** The store, scoped to the EntityCache */\n    private store: Store<EntityCache>\n  ) {\n    // Replay because sometimes in tests will fake data service with synchronous observable\n    // which makes subscriber miss the dispatched actions.\n    // Of course that's a testing mistake. But easy to forget, leading to painful debugging.\n    this.reducedActions$ = scannedActions$.pipe(shareReplay(1));\n    // Start listening so late subscriber won't miss the most recent action.\n    this.raSubscription = this.reducedActions$.subscribe();\n  }\n\n  /**\n   * Dispatch an Action to the store.\n   * @param action the Action\n   * @returns the dispatched Action\n   */\n  dispatch(action: Action): Action {\n    this.store.dispatch(action);\n    return action;\n  }\n\n  /**\n   * Dispatch action to cancel the saveEntities request with matching correlation id.\n   * @param correlationId The correlation id for the corresponding action\n   * @param [reason] explains why canceled and by whom.\n   * @param [entityNames] array of entity names so can turn off loading flag for their collections.\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  cancelSaveEntities(\n    correlationId: any,\n    reason?: string,\n    entityNames?: string[],\n    tag?: string\n  ): void {\n    if (!correlationId) {\n      throw new Error('Missing correlationId');\n    }\n    const action = new SaveEntitiesCancel(\n      correlationId,\n      reason,\n      entityNames,\n      tag\n    );\n    this.dispatch(action);\n  }\n\n  /** Clear the named entity collections in cache\n   * @param [collections] Array of names of the collections to clear.\n   * If empty array, does nothing. If null/undefined/no array, clear all collections.\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  clearCollections(collections?: string[], tag?: string) {\n    this.dispatch(new ClearCollections(collections, tag));\n  }\n\n  /**\n   * Load multiple entity collections at the same time.\n   * before any selectors$ observables emit.\n   * @param collections The collections to load, typically the result of a query.\n   * @param [tag] tag to identify the operation from the app perspective.\n   * in the form of a map of entity collections.\n   */\n  loadCollections(collections: EntityCacheQuerySet, tag?: string) {\n    this.dispatch(new LoadCollections(collections, tag));\n  }\n\n  /**\n   * Merges entities from a query result\n   * that returned entities from multiple collections.\n   * Corresponding entity cache reducer should add and update all collections\n   * at the same time, before any selectors$ observables emit.\n   * @param querySet The result of the query in the form of a map of entity collections.\n   * These are the entity data to merge into the respective collections.\n   * @param mergeStrategy How to merge a queried entity when it is already in the collection.\n   * The default is MergeStrategy.PreserveChanges\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  mergeQuerySet(\n    querySet: EntityCacheQuerySet,\n    mergeStrategy?: MergeStrategy,\n    tag?: string\n  ) {\n    this.dispatch(new MergeQuerySet(querySet, mergeStrategy, tag));\n  }\n\n  /**\n   * Create entity cache action for replacing the entire entity cache.\n   * Dangerous because brute force but useful as when re-hydrating an EntityCache\n   * from local browser storage when the application launches.\n   * @param cache New state of the entity cache\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  setEntityCache(cache: EntityCache, tag?: string) {\n    this.dispatch(new SetEntityCache(cache, tag));\n  }\n\n  /**\n   * Dispatch action to save multiple entity changes to remote storage.\n   * Relies on an Ngrx Effect such as EntityEffects.saveEntities$.\n   * Important: only call if your server supports the SaveEntities protocol\n   * through your EntityDataService.saveEntities method.\n   * @param changes Either the entities to save, as an array of {ChangeSetItem}, or\n   * a ChangeSet that holds such changes.\n   * @param url The server url which receives the save request\n   * @param [options] options such as tag, correlationId, isOptimistic, and mergeStrategy.\n   * These values are defaulted if not supplied.\n   * @returns A terminating Observable<ChangeSet> with data returned from the server\n   * after server reports successful save OR the save error.\n   * TODO: should return the matching entities from cache rather than the raw server data.\n   */\n  saveEntities(\n    changes: ChangeSetItem[] | ChangeSet,\n    url: string,\n    options?: EntityActionOptions\n  ): Observable<ChangeSet> {\n    const changeSet = Array.isArray(changes) ? { changes } : changes;\n    options = options || {};\n    const correlationId =\n      options.correlationId == null\n        ? this.correlationIdGenerator.next()\n        : options.correlationId;\n    const isOptimistic =\n      options.isOptimistic == null\n        ? this.defaultDispatcherOptions.optimisticSaveEntities || false\n        : options.isOptimistic === true;\n    const tag = options.tag || 'Save Entities';\n    options = { ...options, correlationId, isOptimistic, tag };\n    const action = new SaveEntities(changeSet, url, options);\n    this.dispatch(action);\n    return this.getSaveEntitiesResponseData$(options.correlationId).pipe(\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Return Observable of data from the server-success SaveEntities action with\n   * the given Correlation Id, after that action was processed by the ngrx store.\n   * or else put the server error on the Observable error channel.\n   * @param crid The correlationId for both the save and response actions.\n   */\n  private getSaveEntitiesResponseData$(crid: any): Observable<ChangeSet> {\n    /**\n     * reducedActions$ must be replay observable of the most recent action reduced by the store.\n     * because the response action might have been dispatched to the store\n     * before caller had a chance to subscribe.\n     */\n    return this.reducedActions$.pipe(\n      filter(\n        (act: Action) =>\n          act.type === EntityCacheAction.SAVE_ENTITIES_SUCCESS ||\n          act.type === EntityCacheAction.SAVE_ENTITIES_ERROR ||\n          act.type === EntityCacheAction.SAVE_ENTITIES_CANCEL\n      ),\n      filter((act: Action) => crid === (act as any).payload.correlationId),\n      take(1),\n      mergeMap(act => {\n        return act.type === EntityCacheAction.SAVE_ENTITIES_CANCEL\n          ? throwError(\n              new PersistanceCanceled(\n                (act as SaveEntitiesCancel).payload.reason\n              )\n            )\n          : act.type === EntityCacheAction.SAVE_ENTITIES_SUCCESS\n            ? of((act as SaveEntitiesSuccess).payload.changeSet)\n            : throwError((act as SaveEntitiesError).payload);\n      })\n    );\n  }\n}\n"]}