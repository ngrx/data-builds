{"version":3,"file":"entity-collection-reducer-methods.js","sourceRoot":"ng://@ngrx/data/","sources":["src/reducers/entity-collection-reducer-methods.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { EntityAdapter, IdSelector, Update } from '@ngrx/entity';\nimport {\n  ChangeStateMap,\n  ChangeType,\n  EntityCollection,\n} from './entity-collection';\nimport { EntityChangeTrackerBase } from './entity-change-tracker-base';\nimport { toUpdateFactory } from '../utils/utilities';\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionDataServiceError } from '../dataservices/data-service-error';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityChangeTracker } from './entity-change-tracker';\nimport { EntityDefinition } from '../entity-metadata/entity-definition';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\nimport { EntityOp } from '../actions/entity-op';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * Map of {EntityOp} to reducer method for the operation.\n * If an operation is missing, caller should return the collection for that reducer.\n */\nexport interface EntityCollectionReducerMethodMap<T> {\n  [method: string]: (\n    collection: EntityCollection<T>,\n    action: EntityAction\n  ) => EntityCollection<T>;\n}\n\n/**\n * Base implementation of reducer methods for an entity collection.\n */\nexport class EntityCollectionReducerMethods<T> {\n  protected adapter: EntityAdapter<T>;\n  protected guard: EntityActionGuard<T>;\n  /** True if this collection tracks unsaved changes */\n  protected isChangeTracking: boolean;\n\n  /** Extract the primary key (id); default to `id` */\n  selectId: IdSelector<T>;\n\n  /**\n   * Track changes to entities since the last query or save\n   * Can revert some or all of those changes\n   */\n  entityChangeTracker: EntityChangeTracker<T>;\n\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>` object\n   * `id`: the primary key and\n   * `changes`: the entity (or partial entity of changes).\n   */\n  protected toUpdate: (entity: Partial<T>) => Update<T>;\n\n  /**\n   * Dictionary of the {EntityCollectionReducerMethods} for this entity type,\n   * keyed by the {EntityOp}\n   */\n  readonly methods: EntityCollectionReducerMethodMap<T> = {\n    [EntityOp.CANCEL_PERSIST]: this.cancelPersist.bind(this),\n\n    [EntityOp.QUERY_ALL]: this.queryAll.bind(this),\n    [EntityOp.QUERY_ALL_ERROR]: this.queryAllError.bind(this),\n    [EntityOp.QUERY_ALL_SUCCESS]: this.queryAllSuccess.bind(this),\n\n    [EntityOp.QUERY_BY_KEY]: this.queryByKey.bind(this),\n    [EntityOp.QUERY_BY_KEY_ERROR]: this.queryByKeyError.bind(this),\n    [EntityOp.QUERY_BY_KEY_SUCCESS]: this.queryByKeySuccess.bind(this),\n\n    [EntityOp.QUERY_LOAD]: this.queryLoad.bind(this),\n    [EntityOp.QUERY_LOAD_ERROR]: this.queryLoadError.bind(this),\n    [EntityOp.QUERY_LOAD_SUCCESS]: this.queryLoadSuccess.bind(this),\n\n    [EntityOp.QUERY_MANY]: this.queryMany.bind(this),\n    [EntityOp.QUERY_MANY_ERROR]: this.queryManyError.bind(this),\n    [EntityOp.QUERY_MANY_SUCCESS]: this.queryManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_MANY]: this.saveAddMany.bind(this),\n    [EntityOp.SAVE_ADD_MANY_ERROR]: this.saveAddManyError.bind(this),\n    [EntityOp.SAVE_ADD_MANY_SUCCESS]: this.saveAddManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_ONE]: this.saveAddOne.bind(this),\n    [EntityOp.SAVE_ADD_ONE_ERROR]: this.saveAddOneError.bind(this),\n    [EntityOp.SAVE_ADD_ONE_SUCCESS]: this.saveAddOneSuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_MANY]: this.saveDeleteMany.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_ERROR]: this.saveDeleteManyError.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_SUCCESS]: this.saveDeleteManySuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_ONE]: this.saveDeleteOne.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_ERROR]: this.saveDeleteOneError.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_SUCCESS]: this.saveDeleteOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_MANY]: this.saveUpdateMany.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_ERROR]: this.saveUpdateManyError.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_SUCCESS]: this.saveUpdateManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_ONE]: this.saveUpdateOne.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_ERROR]: this.saveUpdateOneError.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_SUCCESS]: this.saveUpdateOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_MANY]: this.saveUpsertMany.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_ERROR]: this.saveUpsertManyError.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_SUCCESS]: this.saveUpsertManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_ONE]: this.saveUpsertOne.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_ERROR]: this.saveUpsertOneError.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_SUCCESS]: this.saveUpsertOneSuccess.bind(this),\n\n    // Do nothing on save errors except turn the loading flag off.\n    // See the ChangeTrackerMetaReducers\n    // Or the app could listen for those errors and do something\n\n    /// cache only operations ///\n\n    [EntityOp.ADD_ALL]: this.addAll.bind(this),\n    [EntityOp.ADD_MANY]: this.addMany.bind(this),\n    [EntityOp.ADD_ONE]: this.addOne.bind(this),\n\n    [EntityOp.REMOVE_ALL]: this.removeAll.bind(this),\n    [EntityOp.REMOVE_MANY]: this.removeMany.bind(this),\n    [EntityOp.REMOVE_ONE]: this.removeOne.bind(this),\n\n    [EntityOp.UPDATE_MANY]: this.updateMany.bind(this),\n    [EntityOp.UPDATE_ONE]: this.updateOne.bind(this),\n\n    [EntityOp.UPSERT_MANY]: this.upsertMany.bind(this),\n    [EntityOp.UPSERT_ONE]: this.upsertOne.bind(this),\n\n    [EntityOp.COMMIT_ALL]: this.commitAll.bind(this),\n    [EntityOp.COMMIT_MANY]: this.commitMany.bind(this),\n    [EntityOp.COMMIT_ONE]: this.commitOne.bind(this),\n    [EntityOp.UNDO_ALL]: this.undoAll.bind(this),\n    [EntityOp.UNDO_MANY]: this.undoMany.bind(this),\n    [EntityOp.UNDO_ONE]: this.undoOne.bind(this),\n\n    [EntityOp.SET_CHANGE_STATE]: this.setChangeState.bind(this),\n    [EntityOp.SET_COLLECTION]: this.setCollection.bind(this),\n    [EntityOp.SET_FILTER]: this.setFilter.bind(this),\n    [EntityOp.SET_LOADED]: this.setLoaded.bind(this),\n    [EntityOp.SET_LOADING]: this.setLoading.bind(this),\n  };\n\n  constructor(\n    public entityName: string,\n    public definition: EntityDefinition<T>,\n    /*\n     * Track changes to entities since the last query or save\n     * Can revert some or all of those changes\n     */\n    entityChangeTracker?: EntityChangeTracker<T>\n  ) {\n    this.adapter = definition.entityAdapter;\n    this.isChangeTracking = definition.noChangeTracking !== true;\n    this.selectId = definition.selectId;\n\n    this.guard = new EntityActionGuard(entityName, this.selectId);\n    this.toUpdate = toUpdateFactory(this.selectId);\n\n    this.entityChangeTracker =\n      entityChangeTracker ||\n      new EntityChangeTrackerBase<T>(this.adapter, this.selectId);\n  }\n\n  /** Cancel a persistence operation */\n  protected cancelPersist(\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  // #region query operations\n\n  protected queryAll(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryAllError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Merges query results per the MergeStrategy\n   * Sets loading flag to false and loaded flag to true.\n   */\n  protected queryAllSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    return {\n      ...this.entityChangeTracker.mergeQueryResults(\n        data,\n        collection,\n        mergeStrategy\n      ),\n      loaded: true,\n      loading: false,\n    };\n  }\n\n  protected queryByKey(\n    collection: EntityCollection<T>,\n    action: EntityAction<number | string>\n  ): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryByKeyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryByKeySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection =\n      data == null\n        ? collection\n        : this.entityChangeTracker.mergeQueryResults(\n            [data],\n            collection,\n            mergeStrategy\n          );\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryLoad(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryLoadError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Replaces all entities in the collection\n   * Sets loaded flag to true, loading flag to false,\n   * and clears changeState for the entire collection.\n   */\n  protected queryLoadSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const data = this.extractData(action);\n    return {\n      ...this.adapter.addAll(data, collection),\n      loading: false,\n      loaded: true,\n      changeState: {},\n    };\n  }\n\n  protected queryMany(\n    collection: EntityCollection<T>,\n    action: EntityAction\n  ): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryManyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    return {\n      ...this.entityChangeTracker.mergeQueryResults(\n        data,\n        collection,\n        mergeStrategy\n      ),\n      loading: false,\n    };\n  }\n  // #endregion query operations\n\n  // #region save operations\n\n  // #region saveAddMany\n  /**\n   * Save multiple new entities.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entities should be added.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of entities.\n   * If saving optimistically, the entities must have their keys.\n   */\n  protected saveAddMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entities = this.guard.mustBeEntities(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackAddMany(\n        entities,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.addMany(entities, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new entities failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new entities are not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveAddManyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddMany\n\n  // #region saveAddOne\n  /**\n   * Successfully saved new entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field),\n   * and may even return additional new entities.\n   * Therefore, upsert the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   * Note: saveAddManySuccess differs from saveAddOneSuccess when optimistic.\n   * saveAddOneSuccess updates (not upserts) with the lone entity from the server.\n   * There is no effect if the entity is not already in cache.\n   * saveAddManySuccess will add an entity if it is not found in cache.\n   */\n  protected saveAddManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entities = this.guard.mustBeEntities(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    if (this.isOptimistic(action)) {\n      collection = this.entityChangeTracker.mergeSaveUpserts(\n        entities,\n        collection,\n        mergeStrategy\n      );\n    } else {\n      collection = this.entityChangeTracker.mergeSaveAdds(\n        entities,\n        collection,\n        mergeStrategy\n      );\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddMany\n\n  // #region saveAddOne\n  /**\n   * Save a new entity.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add entity immediately.\n   * @param collection The collection to which the entity should be added.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an entity.\n   * If saving optimistically, the entity must have a key.\n   */\n  protected saveAddOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entity = this.guard.mustBeEntity(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackAddOne(\n        entity,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.addOne(entity, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save a new entity failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity is not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entity is in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveAddOneError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved a new entity to the server.\n   * If saved pessimistically, add the entity from the server to the collection.\n   * If saved optimistically, the added entity is already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned value (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveAddOneSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entity = this.guard.mustBeEntity(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    if (this.isOptimistic(action)) {\n      const update: UpdateResponseData<T> = this.toUpdate(entity);\n      // Always update the cache with added entity returned from server\n      collection = this.entityChangeTracker.mergeSaveUpdates(\n        [update],\n        collection,\n        mergeStrategy,\n        false /*never skip*/\n      );\n    } else {\n      collection = this.entityChangeTracker.mergeSaveAdds(\n        [entity],\n        collection,\n        mergeStrategy\n      );\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddOne\n\n  // #region saveAddMany\n  // TODO MANY\n  // #endregion saveAddMany\n\n  // #region saveDeleteOne\n  /**\n   * Delete an entity from the server by key and remove it from the collection (if present).\n   * If the entity is an unsaved new entity, remove it from the collection immediately\n   * and skip the server delete request.\n   * An optimistic save removes an existing entity from the collection immediately;\n   * a pessimistic save removes it after the server confirms successful delete.\n   * @param collection Will remove the entity with this key from the collection.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be a primary key or an entity with a key;\n   * this reducer extracts the key from the entity.\n   */\n  protected saveDeleteOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<number | string | T>\n  ): EntityCollection<T> {\n    const toDelete = this.extractData(action);\n    const deleteId =\n      typeof toDelete === 'object'\n        ? this.selectId(toDelete)\n        : (toDelete as string | number);\n    const change = collection.changeState[deleteId];\n    // If entity is already tracked ...\n    if (change) {\n      if (change.changeType === ChangeType.Added) {\n        // Remove the added entity immediately and forget about its changes (via commit).\n        collection = this.adapter.removeOne(deleteId as string, collection);\n        collection = this.entityChangeTracker.commitOne(deleteId, collection);\n        // Should not waste effort trying to delete on the server because it can't be there.\n        action.payload.skip = true;\n      } else {\n        // Re-track it as a delete, even if tracking is turned off for this call.\n        collection = this.entityChangeTracker.trackDeleteOne(\n          deleteId,\n          collection\n        );\n      }\n    }\n\n    // If optimistic delete, track current state and remove immediately.\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackDeleteOne(\n        deleteId,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.removeOne(deleteId as string, collection);\n    }\n\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to delete the entity on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity could still be in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entity is not in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveDeleteOneError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully deleted entity on the server. The key of the deleted entity is in the action payload data.\n   * If saved pessimistically, if the entity is still in the collection it will be removed.\n   * If saved optimistically, the entity has already been removed from the collection.\n   */\n  protected saveDeleteOneSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<number | string>\n  ): EntityCollection<T> {\n    const deleteId = this.extractData(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.mergeSaveDeletes(\n        [deleteId],\n        collection,\n        mergeStrategy\n      );\n    } else {\n      // Pessimistic: ignore mergeStrategy. Remove entity from the collection and from change tracking.\n      collection = this.adapter.removeOne(deleteId as string, collection);\n      collection = this.entityChangeTracker.commitOne(deleteId, collection);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveDeleteOne\n\n  // #region saveDeleteMany\n  /**\n   * Delete multiple entities from the server by key and remove them from the collection (if present).\n   * Removes unsaved new entities from the collection immediately\n   * but the id is still sent to the server for deletion even though the server will not find that entity.\n   * Therefore, the server must be willing to ignore a delete request for an entity it cannot find.\n   * An optimistic save removes existing entities from the collection immediately;\n   * a pessimistic save removes them after the server confirms successful delete.\n   * @param collection Removes entities from this collection.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of primary keys or entities with a key;\n   * this reducer extracts the key from the entity.\n   */\n  protected saveDeleteMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<(number | string | T)[]>\n  ): EntityCollection<T> {\n    const deleteIds = this.extractData(action).map(\n      d => (typeof d === 'object' ? this.selectId(d) : (d as string | number))\n    );\n    deleteIds.forEach(deleteId => {\n      const change = collection.changeState[deleteId];\n      // If entity is already tracked ...\n      if (change) {\n        if (change.changeType === ChangeType.Added) {\n          // Remove the added entity immediately and forget about its changes (via commit).\n          collection = this.adapter.removeOne(deleteId as string, collection);\n          collection = this.entityChangeTracker.commitOne(deleteId, collection);\n          // Should not waste effort trying to delete on the server because it can't be there.\n          action.payload.skip = true;\n        } else {\n          // Re-track it as a delete, even if tracking is turned off for this call.\n          collection = this.entityChangeTracker.trackDeleteOne(\n            deleteId,\n            collection\n          );\n        }\n      }\n    });\n    // If optimistic delete, track current state and remove immediately.\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackDeleteMany(\n        deleteIds,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.removeMany(deleteIds as string[], collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to delete the entities on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entities could still be in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entities are not in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveDeleteManyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully deleted entities on the server. The keys of the deleted entities are in the action payload data.\n   * If saved pessimistically, entities that are still in the collection will be removed.\n   * If saved optimistically, the entities have already been removed from the collection.\n   */\n  protected saveDeleteManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<(number | string)[]>\n  ): EntityCollection<T> {\n    const deleteIds = this.extractData(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.mergeSaveDeletes(\n        deleteIds,\n        collection,\n        mergeStrategy\n      );\n    } else {\n      // Pessimistic: ignore mergeStrategy. Remove entity from the collection and from change tracking.\n      collection = this.adapter.removeMany(deleteIds as string[], collection);\n      collection = this.entityChangeTracker.commitMany(deleteIds, collection);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveDeleteMany\n\n  // #region saveUpdateOne\n  /**\n   * Save an update to an existing entity.\n   * If saving pessimistically, update the entity in the collection after the server confirms success.\n   * If saving optimistically, update the entity immediately, before the save request.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an {Update<T>}\n   */\n  protected saveUpdateOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<Update<T>>\n  ): EntityCollection<T> {\n    const update = this.guard.mustBeUpdate(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpdateOne(\n        update,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.updateOne(update, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to update the entity on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity in the collection is in the pre-save state\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entity in the collection was updated\n   * and you may need to compensate for the error.\n   */\n  protected saveUpdateOneError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved the updated entity to the server.\n   * If saved pessimistically, update the entity in the collection with data from the server.\n   * If saved optimistically, the entity was already updated in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned value (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic update to avoid this risk.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic, and\n   * the update data which, must be an UpdateResponse<T> that corresponds to the Update sent to the server.\n   * You must include an UpdateResponse even if the save was optimistic,\n   * to ensure that the change tracking is properly reset.\n   */\n  protected saveUpdateOneSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<UpdateResponseData<T>>\n  ): EntityCollection<T> {\n    const update = this.guard.mustBeUpdateResponse(action);\n    const isOptimistic = this.isOptimistic(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.mergeSaveUpdates(\n      [update],\n      collection,\n      mergeStrategy,\n      isOptimistic /*skip unchanged if optimistic */\n    );\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpdateOne\n\n  // #region saveUpdateMany\n  /**\n   * Save updated entities.\n   * If saving pessimistically, update the entities in the collection after the server confirms success.\n   * If saving optimistically, update the entities immediately, before the save request.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an array of {Update<T>}.\n   */\n  protected saveUpdateMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<Update<T>[]>\n  ): EntityCollection<T> {\n    const updates = this.guard.mustBeUpdates(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpdateMany(\n        updates,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.updateMany(updates, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to update entities on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entities in the collection are in the pre-save state\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entities in the collection were updated\n   * and you may need to compensate for the error.\n   */\n  protected saveUpdateManyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved the updated entities to the server.\n   * If saved pessimistically, the entities in the collection will be updated with data from the server.\n   * If saved optimistically, the entities in the collection were already updated.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic update to avoid this risk.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an array of UpdateResponse<T>.\n   * You must include an UpdateResponse for every Update sent to the server,\n   * even if the save was optimistic, to ensure that the change tracking is properly reset.\n   */\n  protected saveUpdateManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<UpdateResponseData<T>[]>\n  ): EntityCollection<T> {\n    const updates = this.guard.mustBeUpdateResponses(action);\n    const isOptimistic = this.isOptimistic(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.mergeSaveUpdates(\n      updates,\n      collection,\n      mergeStrategy,\n      false /* never skip */\n    );\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpdateMany\n\n  // #region saveUpsertOne\n  /**\n   * Save a new or existing entity.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entity should be upserted.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be a whole entity.\n   * If saving optimistically, the entity must have its key.\n   */\n  protected saveUpsertOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entity = this.guard.mustBeEntity(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpsertOne(\n        entity,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.upsertOne(entity, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new or existing entity failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new or updated entity is not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveUpsertOneError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved new or existing entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveUpsertOneSuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entity = this.guard.mustBeEntity(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    // Always update the cache with upserted entities returned from server\n    collection = this.entityChangeTracker.mergeSaveUpserts(\n      [entity],\n      collection,\n      mergeStrategy\n    );\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpsertOne\n\n  // #region saveUpsertMany\n  /**\n   * Save multiple new or existing entities.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entities should be upserted.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of whole entities.\n   * If saving optimistically, the entities must have their keys.\n   */\n  protected saveUpsertMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entities = this.guard.mustBeEntities(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpsertMany(\n        entities,\n        collection,\n        mergeStrategy\n      );\n      collection = this.adapter.upsertMany(entities, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new or existing entities failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new entities are not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveUpsertManyError(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityActionDataServiceError>\n  ): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved new or existing entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveUpsertManySuccess(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entities = this.guard.mustBeEntities(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    // Always update the cache with upserted entities returned from server\n    collection = this.entityChangeTracker.mergeSaveUpserts(\n      entities,\n      collection,\n      mergeStrategy\n    );\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpsertMany\n\n  // #endregion save operations\n\n  // #region cache-only operations\n\n  /**\n   * Replaces all entities in the collection\n   * Sets loaded flag to true.\n   * Merges query results, preserving unsaved changes\n   */\n  protected addAll(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const entities = this.guard.mustBeEntities(action);\n    return {\n      ...this.adapter.addAll(entities, collection),\n      loading: false,\n      loaded: true,\n      changeState: {},\n    };\n  }\n\n  protected addMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    const entities = this.guard.mustBeEntities(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackAddMany(\n      entities,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.addMany(entities, collection);\n  }\n\n  protected addOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    const entity = this.guard.mustBeEntity(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackAddOne(\n      entity,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.addOne(entity, collection);\n  }\n\n  protected removeMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<number[] | string[]>\n  ): EntityCollection<T> {\n    // payload must be entity keys\n    const keys = this.guard.mustBeKeys(action) as string[];\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackDeleteMany(\n      keys,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.removeMany(keys, collection);\n  }\n\n  protected removeOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<number | string>\n  ): EntityCollection<T> {\n    // payload must be entity key\n    const key = this.guard.mustBeKey(action) as string;\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackDeleteOne(\n      key,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.removeOne(key, collection);\n  }\n\n  protected removeAll(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    return {\n      ...this.adapter.removeAll(collection),\n      loaded: false, // Only REMOVE_ALL sets loaded to false\n      loading: false,\n      changeState: {}, // Assume clearing the collection and not trying to delete all entities\n    };\n  }\n\n  protected updateMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<Update<T>[]>\n  ): EntityCollection<T> {\n    // payload must be an array of `Updates<T>`, not entities\n    const updates = this.guard.mustBeUpdates(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpdateMany(\n      updates,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.updateMany(updates, collection);\n  }\n\n  protected updateOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<Update<T>>\n  ): EntityCollection<T> {\n    // payload must be an `Update<T>`, not an entity\n    const update = this.guard.mustBeUpdate(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpdateOne(\n      update,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.updateOne(update, collection);\n  }\n\n  protected upsertMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ): EntityCollection<T> {\n    // <v6: payload must be an array of `Updates<T>`, not entities\n    // v6+: payload must be an array of T\n    const entities = this.guard.mustBeEntities(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpsertMany(\n      entities,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.upsertMany(entities, collection);\n  }\n\n  protected upsertOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ): EntityCollection<T> {\n    // <v6: payload must be an `Update<T>`, not an entity\n    // v6+: payload must be a T\n    const entity = this.guard.mustBeEntity(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpsertOne(\n      entity,\n      collection,\n      mergeStrategy\n    );\n    return this.adapter.upsertOne(entity, collection);\n  }\n\n  protected commitAll(collection: EntityCollection<T>) {\n    return this.entityChangeTracker.commitAll(collection);\n  }\n\n  protected commitMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ) {\n    return this.entityChangeTracker.commitMany(\n      this.extractData(action),\n      collection\n    );\n  }\n\n  protected commitOne(\n    collection: EntityCollection<T>,\n    action: EntityAction<T>\n  ) {\n    return this.entityChangeTracker.commitOne(\n      this.extractData(action),\n      collection\n    );\n  }\n\n  protected undoAll(collection: EntityCollection<T>) {\n    return this.entityChangeTracker.undoAll(collection);\n  }\n\n  protected undoMany(\n    collection: EntityCollection<T>,\n    action: EntityAction<T[]>\n  ) {\n    return this.entityChangeTracker.undoMany(\n      this.extractData(action),\n      collection\n    );\n  }\n\n  protected undoOne(collection: EntityCollection<T>, action: EntityAction<T>) {\n    return this.entityChangeTracker.undoOne(\n      this.extractData(action),\n      collection\n    );\n  }\n\n  /** Dangerous: Completely replace the collection's ChangeState. Use rarely and wisely. */\n  protected setChangeState(\n    collection: EntityCollection<T>,\n    action: EntityAction<ChangeStateMap<T>>\n  ) {\n    const changeState = this.extractData(action);\n    return collection.changeState === changeState\n      ? collection\n      : { ...collection, changeState };\n  }\n\n  /**\n   * Dangerous: Completely replace the collection.\n   * Primarily for testing and rehydration from local storage.\n   * Use rarely and wisely.\n   */\n  protected setCollection(\n    collection: EntityCollection<T>,\n    action: EntityAction<EntityCollection<T>>\n  ) {\n    const newCollection = this.extractData(action);\n    return collection === newCollection ? collection : newCollection;\n  }\n\n  protected setFilter(\n    collection: EntityCollection<T>,\n    action: EntityAction<any>\n  ): EntityCollection<T> {\n    const filter = this.extractData(action);\n    return collection.filter === filter\n      ? collection\n      : { ...collection, filter };\n  }\n\n  protected setLoaded(\n    collection: EntityCollection<T>,\n    action: EntityAction<boolean>\n  ): EntityCollection<T> {\n    const loaded = this.extractData(action) === true || false;\n    return collection.loaded === loaded\n      ? collection\n      : { ...collection, loaded };\n  }\n\n  protected setLoading(\n    collection: EntityCollection<T>,\n    action: EntityAction<boolean>\n  ): EntityCollection<T> {\n    return this.setLoadingFlag(collection, this.extractData(action));\n  }\n\n  protected setLoadingFalse(\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    return this.setLoadingFlag(collection, false);\n  }\n\n  protected setLoadingTrue(\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    return this.setLoadingFlag(collection, true);\n  }\n\n  /** Set the collection's loading flag */\n  protected setLoadingFlag(collection: EntityCollection<T>, loading: boolean) {\n    loading = loading === true ? true : false;\n    return collection.loading === loading\n      ? collection\n      : { ...collection, loading };\n  }\n  // #endregion Cache-only operations\n\n  // #region helpers\n  /** Safely extract data from the EntityAction payload */\n  protected extractData<D = any>(action: EntityAction<D>): D {\n    return (action.payload && action.payload.data) as D;\n  }\n\n  /** Safely extract MergeStrategy from EntityAction. Set to IgnoreChanges if collection itself is not tracked. */\n  protected extractMergeStrategy(action: EntityAction) {\n    // If not tracking this collection, always ignore changes\n    return this.isChangeTracking\n      ? action.payload && action.payload.mergeStrategy\n      : MergeStrategy.IgnoreChanges;\n  }\n\n  protected isOptimistic(action: EntityAction) {\n    return action.payload && action.payload.isOptimistic === true;\n  }\n\n  // #endregion helpers\n}\n\n/**\n * Creates {EntityCollectionReducerMethods} for a given entity type.\n */\n@Injectable()\nexport class EntityCollectionReducerMethodsFactory {\n  constructor(private entityDefinitionService: EntityDefinitionService) {}\n\n  /** Create the  {EntityCollectionReducerMethods} for the named entity type */\n  create<T>(entityName: string): EntityCollectionReducerMethodMap<T> {\n    const definition = this.entityDefinitionService.getDefinition<T>(\n      entityName\n    );\n    const methodsClass = new EntityCollectionReducerMethods(\n      entityName,\n      definition\n    );\n\n    return methodsClass.methods;\n  }\n}\n"]}