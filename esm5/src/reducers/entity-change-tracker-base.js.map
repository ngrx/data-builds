{"version":3,"file":"entity-change-tracker-base.js","sourceRoot":"ng://@ngrx/data/","sources":["src/reducers/entity-change-tracker-base.ts"],"names":[],"mappings":"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","sourcesContent":["import { EntityAdapter, IdSelector, Update } from '@ngrx/entity';\n\nimport { ChangeType, EntityCollection } from './entity-collection';\nimport { defaultSelectId } from '../utils/utilities';\nimport { EntityChangeTracker } from './entity-change-tracker';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * The default implementation of EntityChangeTracker with\n * methods for tracking, committing, and reverting/undoing unsaved entity changes.\n * Used by EntityCollectionReducerMethods which should call tracker methods BEFORE modifying the collection.\n * See EntityChangeTracker docs.\n */\nexport class EntityChangeTrackerBase<T> implements EntityChangeTracker<T> {\n  constructor(\n    private adapter: EntityAdapter<T>,\n    private selectId: IdSelector<T>\n  ) {\n    /** Extract the primary key (id); default to `id` */\n    this.selectId = selectId || defaultSelectId;\n  }\n\n  // #region commit methods\n  /**\n   * Commit all changes as when the collection has been completely reloaded from the server.\n   * Harmless when there are no entity changes to commit.\n   * @param collection The entity collection\n   */\n  commitAll(collection: EntityCollection<T>): EntityCollection<T> {\n    return Object.keys(collection.changeState).length === 0\n      ? collection\n      : { ...collection, changeState: {} };\n  }\n\n  /**\n   * Commit changes for the given entities as when they have been refreshed from the server.\n   * Harmless when there are no entity changes to commit.\n   * @param entityOrIdList The entities to clear tracking or their ids.\n   * @param collection The entity collection\n   */\n  commitMany(\n    entityOrIdList: (number | string | T)[],\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    if (entityOrIdList == null || entityOrIdList.length === 0) {\n      return collection; // nothing to commit\n    }\n    let didMutate = false;\n    const changeState = entityOrIdList.reduce((chgState, entityOrId) => {\n      const id =\n        typeof entityOrId === 'object'\n          ? this.selectId(entityOrId)\n          : (entityOrId as string | number);\n      if (chgState[id]) {\n        if (!didMutate) {\n          chgState = { ...chgState };\n          didMutate = true;\n        }\n        delete chgState[id];\n      }\n      return chgState;\n    }, collection.changeState);\n\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Commit changes for the given entity as when it have been refreshed from the server.\n   * Harmless when no entity changes to commit.\n   * @param entityOrId The entity to clear tracking or its id.\n   * @param collection The entity collection\n   */\n  commitOne(\n    entityOrId: number | string | T,\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    return entityOrId == null\n      ? collection\n      : this.commitMany([entityOrId], collection);\n  }\n\n  // #endregion commit methods\n\n  // #region merge query\n  /**\n   * Merge query results into the collection, adjusting the ChangeState per the mergeStrategy.\n   * @param entities Entities returned from querying the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a queried entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.PreserveChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeQueryResults(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return this.mergeServerUpserts(\n      entities,\n      collection,\n      MergeStrategy.PreserveChanges,\n      mergeStrategy\n    );\n  }\n  // #endregion merge query results\n\n  // #region merge save results\n  /**\n   * Merge result of saving new entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param entities Entities returned from saving new entities to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveAdds(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return this.mergeServerUpserts(\n      entities,\n      collection,\n      MergeStrategy.OverwriteChanges,\n      mergeStrategy\n    );\n  }\n\n  /**\n   * Merge successful result of deleting entities on the server that have the given primary keys\n   * Clears the entity changeState for those keys unless the MergeStrategy is ignoreChanges.\n   * @param entities keys primary keys of the entities to remove/delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to adjust change tracking when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveDeletes(\n    keys: (number | string)[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    mergeStrategy =\n      mergeStrategy == null ? MergeStrategy.OverwriteChanges : mergeStrategy;\n    // same logic for all non-ignore merge strategies: always clear (commit) the changes\n    const deleteIds = keys as string[]; // make TypeScript happy\n    collection =\n      mergeStrategy === MergeStrategy.IgnoreChanges\n        ? collection\n        : this.commitMany(deleteIds, collection);\n    return this.adapter.removeMany(deleteIds, collection);\n  }\n\n  /**\n   * Merge result of saving updated entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param updateResponseData Entity response data returned from saving updated entities to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @param [skipUnchanged] True means skip update if server didn't change it. False by default.\n   * If the update was optimistic and the server didn't make more changes of its own\n   * then the updates are already in the collection and shouldn't make them again.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveUpdates(\n    updateResponseData: UpdateResponseData<T>[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy,\n    skipUnchanged = false\n  ): EntityCollection<T> {\n    if (updateResponseData == null || updateResponseData.length === 0) {\n      return collection; // nothing to merge.\n    }\n\n    let didMutate = false;\n    let changeState = collection.changeState;\n    mergeStrategy =\n      mergeStrategy == null ? MergeStrategy.OverwriteChanges : mergeStrategy;\n    let updates: Update<T>[];\n\n    switch (mergeStrategy) {\n      case MergeStrategy.IgnoreChanges:\n        updates = filterChanged(updateResponseData);\n        return this.adapter.updateMany(updates, collection);\n\n      case MergeStrategy.OverwriteChanges:\n        changeState = updateResponseData.reduce((chgState, update) => {\n          const oldId = update.id;\n          const change = chgState[oldId];\n          if (change) {\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            delete chgState[oldId];\n          }\n          return chgState;\n        }, collection.changeState);\n\n        collection = didMutate ? { ...collection, changeState } : collection;\n\n        updates = filterChanged(updateResponseData);\n        return this.adapter.updateMany(updates, collection);\n\n      case MergeStrategy.PreserveChanges: {\n        const updateableEntities = [] as UpdateResponseData<T>[];\n        changeState = updateResponseData.reduce((chgState, update) => {\n          const oldId = update.id;\n          const change = chgState[oldId];\n          if (change) {\n            // Tracking a change so update original value but not the current value\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            const newId = this.selectId(update.changes as T);\n            const oldChangeState = change;\n            // If the server changed the id, register the new \"originalValue\" under the new id\n            // and remove the change tracked under the old id.\n            if (newId !== oldId) {\n              delete chgState[oldId];\n            }\n            const newOrigValue = {\n              ...(oldChangeState!.originalValue as any),\n              ...(update.changes as any),\n            };\n            (chgState as any)[newId] = {\n              ...oldChangeState,\n              originalValue: newOrigValue,\n            };\n          } else {\n            updateableEntities.push(update);\n          }\n          return chgState;\n        }, collection.changeState);\n        collection = didMutate ? { ...collection, changeState } : collection;\n\n        updates = filterChanged(updateableEntities);\n        return this.adapter.updateMany(updates, collection);\n      }\n    }\n\n    /**\n     * Conditionally keep only those updates that have additional server changes.\n     * (e.g., for optimistic saves because they updates are already in the current collection)\n     * Strip off the `changed` property.\n     * @responseData Entity response data from server.\n     * May be an UpdateResponseData<T>, a subclass of Update<T> with a 'changed' flag.\n     * @returns Update<T> (without the changed flag)\n     */\n    function filterChanged(responseData: UpdateResponseData<T>[]): Update<T>[] {\n      if (skipUnchanged === true) {\n        // keep only those updates that the server changed (knowable if is UpdateResponseData<T>)\n        responseData = responseData.filter(r => r.changed === true);\n      }\n      // Strip unchanged property from responseData, leaving just the pure Update<T>\n      // TODO: Remove? probably not necessary as the Update isn't stored and adapter will ignore `changed`.\n      return responseData.map(r => ({ id: r.id as any, changes: r.changes }));\n    }\n  }\n\n  /**\n   * Merge result of saving upserted entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param entities Entities returned from saving upserts to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveUpserts(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return this.mergeServerUpserts(\n      entities,\n      collection,\n      MergeStrategy.OverwriteChanges,\n      mergeStrategy\n    );\n  }\n  // #endregion merge save results\n\n  // #region query & save helpers\n  /**\n   *\n   * @param entities Entities to merge\n   * @param collection Collection into which entities are merged\n   * @param defaultMergeStrategy How to merge when action's MergeStrategy is unspecified\n   * @param [mergeStrategy] The action's MergeStrategy\n   */\n  private mergeServerUpserts(\n    entities: T[],\n    collection: EntityCollection<T>,\n    defaultMergeStrategy: MergeStrategy,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (entities == null || entities.length === 0) {\n      return collection; // nothing to merge.\n    }\n\n    let didMutate = false;\n    let changeState = collection.changeState;\n    mergeStrategy =\n      mergeStrategy == null ? defaultMergeStrategy : mergeStrategy;\n\n    switch (mergeStrategy) {\n      case MergeStrategy.IgnoreChanges:\n        return this.adapter.upsertMany(entities, collection);\n\n      case MergeStrategy.OverwriteChanges:\n        collection = this.adapter.upsertMany(entities, collection);\n\n        changeState = entities.reduce((chgState, entity) => {\n          const id = this.selectId(entity);\n          const change = chgState[id];\n          if (change) {\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            delete chgState[id];\n          }\n          return chgState;\n        }, collection.changeState);\n\n        return didMutate ? { ...collection, changeState } : collection;\n\n      case MergeStrategy.PreserveChanges: {\n        const upsertEntities = [] as T[];\n        changeState = entities.reduce((chgState, entity) => {\n          const id = this.selectId(entity);\n          const change = chgState[id];\n          if (change) {\n            if (!didMutate) {\n              chgState = {\n                ...chgState,\n                [id]: {\n                  ...chgState[id]!,\n                  originalValue: entity,\n                },\n              };\n              didMutate = true;\n            }\n          } else {\n            upsertEntities.push(entity);\n          }\n          return chgState;\n        }, collection.changeState);\n\n        collection = this.adapter.upsertMany(upsertEntities, collection);\n        return didMutate ? { ...collection, changeState } : collection;\n      }\n    }\n  }\n  // #endregion query & save helpers\n\n  // #region track methods\n  /**\n   * Track multiple entities before adding them to the collection.\n   * Does NOT add to the collection (the reducer's job).\n   * @param entities The entities to add. They must all have their ids.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackAddMany(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (\n      mergeStrategy === MergeStrategy.IgnoreChanges ||\n      entities == null ||\n      entities.length === 0\n    ) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const changeState = entities.reduce((chgState, entity) => {\n      const id = this.selectId(entity);\n      if (id == null || id === '') {\n        throw new Error(\n          `${collection.entityName} entity add requires a key to be tracked`\n        );\n      }\n      const trackedChange = chgState[id];\n\n      if (!trackedChange) {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n        chgState[id] = { changeType: ChangeType.Added };\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before adding it to the collection.\n   * Does NOT add to the collection (the reducer's job).\n   * @param entity The entity to add. It must have an id.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   * If not specified, implementation supplies a default strategy.\n   */\n  trackAddOne(\n    entity: T,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return entity == null\n      ? collection\n      : this.trackAddMany([entity], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before removing them with the intention of deleting them on the server.\n   * Does NOT remove from the collection (the reducer's job).\n   * @param keys The primary keys of the entities to delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackDeleteMany(\n    keys: (number | string)[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (\n      mergeStrategy === MergeStrategy.IgnoreChanges ||\n      keys == null ||\n      keys.length === 0\n    ) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = keys.reduce((chgState, id) => {\n      const originalValue = entityMap[id];\n      if (originalValue) {\n        const trackedChange = chgState[id];\n        if (trackedChange) {\n          if (trackedChange.changeType === ChangeType.Added) {\n            // Special case: stop tracking an added entity that you delete\n            // The caller must also detect this, remove it immediately from the collection\n            // and skip attempt to delete on the server.\n            cloneChgStateOnce();\n            delete chgState[id];\n          } else if (trackedChange.changeType === ChangeType.Updated) {\n            // Special case: switch change type from Updated to Deleted.\n            cloneChgStateOnce();\n            trackedChange.changeType = ChangeType.Deleted;\n          }\n        } else {\n          // Start tracking this entity\n          cloneChgStateOnce();\n          chgState[id] = { changeType: ChangeType.Deleted, originalValue };\n        }\n      }\n      return chgState;\n\n      function cloneChgStateOnce() {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n      }\n    }, collection.changeState);\n\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before it is removed with the intention of deleting it on the server.\n   * Does NOT remove from the collection (the reducer's job).\n   * @param key The primary key of the entity to delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackDeleteOne(\n    key: number | string,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return key == null\n      ? collection\n      : this.trackDeleteMany([key], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before updating them in the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param updates The entities to update.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpdateMany(\n    updates: Update<T>[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (\n      mergeStrategy === MergeStrategy.IgnoreChanges ||\n      updates == null ||\n      updates.length === 0\n    ) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = updates.reduce((chgState, update) => {\n      const { id, changes: entity } = update;\n      if (id == null || id === '') {\n        throw new Error(\n          `${collection.entityName} entity update requires a key to be tracked`\n        );\n      }\n      const originalValue = entityMap[id];\n      // Only track if it is in the collection. Silently ignore if it is not.\n      // @ngrx/entity adapter would also silently ignore.\n      // Todo: should missing update entity really be reported as an error?\n      if (originalValue) {\n        const trackedChange = chgState[id];\n        if (!trackedChange) {\n          if (!didMutate) {\n            didMutate = true;\n            chgState = { ...chgState };\n          }\n          chgState[id] = { changeType: ChangeType.Updated, originalValue };\n        }\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before updating it in the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param update The entity to update.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpdateOne(\n    update: Update<T>,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return update == null\n      ? collection\n      : this.trackUpdateMany([update], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before upserting (adding and updating) them to the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param entities The entities to add or update. They must be complete entities with ids.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpsertMany(\n    entities: T[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (\n      mergeStrategy === MergeStrategy.IgnoreChanges ||\n      entities == null ||\n      entities.length === 0\n    ) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = entities.reduce((chgState, entity) => {\n      const id = this.selectId(entity);\n      if (id == null || id === '') {\n        throw new Error(\n          `${collection.entityName} entity upsert requires a key to be tracked`\n        );\n      }\n      const trackedChange = chgState[id];\n\n      if (!trackedChange) {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n\n        const originalValue = entityMap[id];\n        chgState[id] =\n          originalValue == null\n            ? { changeType: ChangeType.Added }\n            : { changeType: ChangeType.Updated, originalValue };\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before upsert (adding and updating) it to the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param entities The entity to add or update. It must be a complete entity with its id.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpsertOne(\n    entity: T,\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    return entity == null\n      ? collection\n      : this.trackUpsertMany([entity], collection, mergeStrategy);\n  }\n  // #endregion track methods\n\n  // #region undo methods\n  /**\n   * Revert the unsaved changes for all collection.\n   * Harmless when there are no entity changes to undo.\n   * @param collection The entity collection\n   */\n  undoAll(collection: EntityCollection<T>): EntityCollection<T> {\n    const ids = Object.keys(collection.changeState);\n\n    const { remove, upsert } = ids.reduce(\n      (acc, id) => {\n        const changeState = acc.chgState[id]!;\n        switch (changeState.changeType) {\n          case ChangeType.Added:\n            acc.remove.push(id);\n            break;\n          case ChangeType.Deleted:\n            const removed = changeState!.originalValue;\n            if (removed) {\n              acc.upsert.push(removed);\n            }\n            break;\n          case ChangeType.Updated:\n            acc.upsert.push(changeState!.originalValue!);\n            break;\n        }\n        return acc;\n      },\n      // entitiesToUndo\n      {\n        remove: [] as (number | string)[],\n        upsert: [] as T[],\n        chgState: collection.changeState,\n      }\n    );\n\n    collection = this.adapter.removeMany(remove as string[], collection);\n    collection = this.adapter.upsertMany(upsert, collection);\n\n    return { ...collection, changeState: {} };\n  }\n\n  /**\n   * Revert the unsaved changes for the given entities.\n   * Harmless when there are no entity changes to undo.\n   * @param entityOrIdList The entities to revert or their ids.\n   * @param collection The entity collection\n   */\n  undoMany(\n    entityOrIdList: (number | string | T)[],\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    if (entityOrIdList == null || entityOrIdList.length === 0) {\n      return collection; // nothing to undo\n    }\n    let didMutate = false;\n\n    const { changeState, remove, upsert } = entityOrIdList.reduce(\n      (acc, entityOrId) => {\n        let chgState = acc.changeState;\n        const id =\n          typeof entityOrId === 'object'\n            ? this.selectId(entityOrId)\n            : (entityOrId as string | number);\n        const change = chgState[id]!;\n        if (change) {\n          if (!didMutate) {\n            chgState = { ...chgState };\n            didMutate = true;\n          }\n          delete chgState[id]; // clear tracking of this entity\n          acc.changeState = chgState;\n          switch (change.changeType) {\n            case ChangeType.Added:\n              acc.remove.push(id);\n              break;\n            case ChangeType.Deleted:\n              const removed = change!.originalValue;\n              if (removed) {\n                acc.upsert.push(removed);\n              }\n              break;\n            case ChangeType.Updated:\n              acc.upsert.push(change!.originalValue!);\n              break;\n          }\n        }\n        return acc;\n      },\n      // entitiesToUndo\n      {\n        remove: [] as (number | string)[],\n        upsert: [] as T[],\n        changeState: collection.changeState,\n      }\n    );\n\n    collection = this.adapter.removeMany(remove as string[], collection);\n    collection = this.adapter.upsertMany(upsert, collection);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Revert the unsaved changes for the given entity.\n   * Harmless when there are no entity changes to undo.\n   * @param entityOrId The entity to revert or its id.\n   * @param collection The entity collection\n   */\n  undoOne(\n    entityOrId: number | string | T,\n    collection: EntityCollection<T>\n  ): EntityCollection<T> {\n    return entityOrId == null\n      ? collection\n      : this.undoMany([entityOrId], collection);\n  }\n  // #endregion undo methods\n}\n"]}